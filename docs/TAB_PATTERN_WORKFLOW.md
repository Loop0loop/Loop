# 🔄 탭 패턴 비교: 실제 동작 흐름

## 시나리오: 4개 章 오가다가 모두 닫는 경우

---

## 📊 패턴 A: 브라우저 스택 (MRU)

### 시각적 흐름

```
┌─────────────────────────────────────────────────────────────────┐
│ 초기 상태                                                        │
├─────────────────────────────────────────────────────────────────┤
│ Tabs:    [章1]    [章2]    [章3]  → [章4] ← activeTab           │
│ History: [章1] → [章2] → [章3] → [章4]                          │
│                                    ↑                             │
│                              Most Recently Used (MRU)            │
└─────────────────────────────────────────────────────────────────┘

👆 User: 章4 탭의 X 클릭

┌─────────────────────────────────────────────────────────────────┐
│ 1단계: 章4 닫기                                                  │
├─────────────────────────────────────────────────────────────────┤
│ Tabs:    [章1]    [章2]  → [章3] ← activeTab (MRU에서 복구)   │
│ History: [章1] → [章2] → [章3]                                  │
│                            ↑                                     │
│                    가장 최근 방문                                │
│                                                                  │
│ ✅ 사용자 경험: "아, 최근에 본 탭으로 가네"                     │
└─────────────────────────────────────────────────────────────────┘

👆 User: 章3 탭의 X 클릭

┌─────────────────────────────────────────────────────────────────┐
│ 2단계: 章3 닫기                                                  │
├─────────────────────────────────────────────────────────────────┤
│ Tabs:    [章1]  → [章2] ← activeTab (MRU에서 복구)            │
│ History: [章1] → [章2]                                          │
│                    ↑                                             │
│            가장 최근 방문                                        │
└─────────────────────────────────────────────────────────────────┘

👆 User: 章2 탭의 X 클릭

┌─────────────────────────────────────────────────────────────────┐
│ 3단계: 章2 닫기                                                  │
├─────────────────────────────────────────────────────────────────┤
│ Tabs:  → [章1] ← activeTab (MRU에서 복구)                      │
│ History: [章1]                                                  │
│           ↑                                                      │
│     마지막 남은 탭                                              │
│                                                                  │
│ 📌 중요: 章1은 닫을 수 없음 (항상 1개는 유지)                  │
└─────────────────────────────────────────────────────────────────┘

👆 User: 章1 X 클릭 → 무시됨 (최소 1개 탭 유지 정책)

┌─────────────────────────────────────────────────────────────────┐
│ 최종: 章1 항상 유지                                             │
├─────────────────────────────────────────────────────────────────┤
│ Tabs:  → [章1] ← activeTab                                     │
│                                                                  │
│ 상태 보관:                                                      │
│ - 4개 히스토리 유지 (메모리)                                    │
│ - MRU 매커니즘 지속 실행                                        │
└─────────────────────────────────────────────────────────────────┘
```

### 코드 로직

```typescript
// 브라우저 패턴: MRU 기반
const tabHistory = [章1, 章2, 章3, 章4];
const activeTab = 章4;

function closeTab(tabToClose: string) {
  tabs = tabs.filter(t => t.id !== tabToClose);
  
  // MRU: 히스토리에서 유효한 탭 찾기
  for (const tab of tabHistory) {
    if (tabs.find(t => t.id === tab)) {
      activeTab = tab;  // ← 복구
      return;
    }
  }
  
  // Fallback: 첫 탭 (이론상 항상 남음)
  activeTab = tabs[0];
}
```

---

## 🎯 패턴 B: primaryChapterId (Fallback)

### 시각적 흐름

```
┌─────────────────────────────────────────────────────────────────┐
│ 초기 상태                                                        │
├─────────────────────────────────────────────────────────────────┤
│ Tabs:           [章1]    [章2]    [章3]  → [章4] ← activeTab   │
│ primaryChapterId: 章1 (첫 탭, 영구 보호)                       │
│                   ↑                                              │
│                 "최후의 보류"                                    │
└─────────────────────────────────────────────────────────────────┘

👆 User: 章4 탭의 X 클릭

┌─────────────────────────────────────────────────────────────────┐
│ 1단계: 章4 닫기 → 직전 탭(章3)으로 이동                        │
├─────────────────────────────────────────────────────────────────┤
│ Tabs:    [章1]    [章2]  → [章3] ← activeTab (직전 탭)         │
│ primaryChapterId: 章1 (유지)                                   │
│                   ↑                                              │
│                 여전히 보호됨                                    │
│                                                                  │
│ ✅ 사용자 경험: "닫은 탭 직전 탭으로 이동"                     │
└─────────────────────────────────────────────────────────────────┘

👆 User: 章3 탭의 X 클릭

┌─────────────────────────────────────────────────────────────────┐
│ 2단계: 章3 닫기 → 직전 탭(章2)으로 이동                        │
├─────────────────────────────────────────────────────────────────┤
│ Tabs:    [章1]  → [章2] ← activeTab (직전 탭)                 │
│ primaryChapterId: 章1 (유지)                                   │
│                   ↑                                              │
│                 여전히 보호됨                                    │
└─────────────────────────────────────────────────────────────────┘

👆 User: 章2 탭의 X 클릭

┌─────────────────────────────────────────────────────────────────┐
│ 3단계: 章2 닫기 → 직전 탭(章1)으로 이동                        │
├─────────────────────────────────────────────────────────────────┤
│ Tabs: → [章1] ← activeTab (직전 탭 = primaryChapter)           │
│ primaryChapterId: 章1                                           │
│                   ↑                                              │
│           자동으로 현재 활성 탭이 됨                           │
└─────────────────────────────────────────────────────────────────┘

👆 User: 章1 X 클릭 → 어떻게 할까?

┌─────────────────────────────────────────────────────────────────┐
│ 💡 옵션 1: 닫기 방지 (권장)                                     │
├─────────────────────────────────────────────────────────────────┤
│ Tabs: → [章1] ← activeTab                                      │
│                                                                  │
│ 동작: 탭 닫기 무시, 장 유지                                     │
│ 메시지: (토스트) "마지막 장입니다"                             │
│                                                                  │
│ 또는                                                             │
│                                                                  │
│ 💡 옵션 2: 자동 새 장 생성 (고급)                              │
├─────────────────────────────────────────────────────────────────┤
│ Tabs: → [新장] ← activeTab (새 장 생성됨)                      │
│ primaryChapterId: 新章                                          │
│                                                                  │
│ 동작: 새 빈 장 자동 생성 + 활성화                              │
│ 사용자: "어? 자동으로 새 장이 생겼네?"                        │
└─────────────────────────────────────────────────────────────────┘
```

### 코드 로직

```typescript
// primaryChapterId 패턴: Fallback 기반
const tabs = [章1, 章2, 章3, 章4];
const activeTab = 章4;
const primaryChapterId = 章1;

function closeTab(tabToClose: string) {
  tabs = tabs.filter(t => t.id !== tabToClose);
  
  // 현재 활성 탭 닫았으면 직전 탭으로 이동
  if (tabToClose === activeTab) {
    // 직전 탭 찾기 (간단한 인덱스 기반)
    const closedIndex = tabs.findIndex(t => t.id === tabToClose);
    activeTab = tabs[closedIndex - 1] || tabs[closedIndex] || null;
    
    // Fallback: primaryChapterId로 복구
    if (!activeTab) {
      activeTab = `chapter-${primaryChapterId}`;
    }
  }
  
  // 특수 처리: 마지막 탭을 닫으려 하면?
  if (tabs.length === 1 && tabs[0].id === `chapter-${primaryChapterId}`) {
    // ✅ 옵션 1: 닫기 방지
    return; // 무시
    
    // 또는 ✅ 옵션 2: 새 장 생성
    // createNewChapter();
  }
}
```

---

## 📈 비교: 두 패턴의 상태 변화

### 메모리 사용

```
브라우저 패턴:
───────────────
초기: tabHistory = [章1, 章2, 章3, 章4] → 메모리 4
1회 닫기: tabHistory = [章1, 章2, 章3] → 메모리 3
2회 닫기: tabHistory = [章1, 章2] → 메모리 2
3회 닫기: tabHistory = [章1] → 메모리 1
총 영속: 항상 히스토리 저장 중

primaryChapterId 패턴:
──────────────────────
초기: primaryChapterId = "章1" → 메모리 1 (상수)
1회 닫기: primaryChapterId = "章1" → 메모리 1 (변동 없음)
2회 닫기: primaryChapterId = "章1" → 메모리 1 (변동 없음)
3회 닫기: primaryChapterId = "章1" → 메모리 1 (변동 없음)
총 영속: 항상 상수 (효율적)
```

### 사용자 심리

```
브라우저 패턴:
─────────────
"아, 최근에 봤던 탭으로 자동 이동하네"
→ 친숙함 (웹 브라우저 경험)
→ 하지만 "章 선택 중심"과는 안 맞음

primaryChapterId 패턴:
─────────────────────
"닫은 탭 직전 탭으로 이동하네"
→ 직관적
→ "장 선택" 중심의 작성 앱과 자연스러움
→ primaryChapter 개념은 학습 필요 (하지만 곧 익숙해짐)
```

---

## 🎓 결론: 어느 것이 "장편 소설 작가"에게 맞을까?

### 작가의 전형적 워크플로우

```
1️⃣ 프로젝트 열기 → 1장 자동 표시 ✅
2️⃣ 3장 열기 → "3장으로 이동"
3️⃣ 5장 열기 → "5장으로 이동"
4️⃣ 2장 열기 → "2장으로 이동"
5️⃣ 3장 닫기 → "2장으로 복원" (직전 탭)
6️⃣ 2장 닫기 → "5장으로 복원" (직전 탭)
7️⃣ 5장 닫기 → "1장으로 복원" (primaryChapter - 안전)
```

**primaryChapterId 패턴이 충분함** ✅

---

## 💭 고민: 브라우저 같은 "뒤로 가기"도 원하나?

### 추가 가능한 기능 (Phase 2)

```typescript
// 간단한 MRU 히스토리 추가 (선택사항)
const tabHistory = [章1, 章2, 章3, 章4];  // 최근 5개만
const primaryChapterId = 章1;

// Ctrl+Tab: 이전 탭으로
function goToPreviousTab() {
  const prevTab = tabHistory[1];  // 두 번째 = 이전
  activeTab = prevTab;
}

// 이러면 "브라우저 같은 경험" + "primaryChapter 안정성" 동시 만족 🎉
```

**결론**: primaryChapterId로 시작 → 필요 시 MRU 추가


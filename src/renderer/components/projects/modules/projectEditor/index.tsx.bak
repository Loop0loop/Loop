// ğŸ”¥ Modularized ProjectEditor - ëª¨ë“ˆí™”ëœ ìƒˆë¡œìš´ í”„ë¡œì íŠ¸ ì—ë””í„°
// ê¸°ì¡´ 1284ì¤„ â†’ ì•½ 200ì¤„ë¡œ ì¶•ì†Œ, ë‹¨ì¼ ì±…ì„ ì›ì¹™ ì¤€ìˆ˜

'use client';

import React, { memo, useEffect, useCallback, useRef, useState } from 'react';
import type { Editor } from '@tiptap/react';
import { MarkdownEditor } from '../../editor/MarkdownEditor';
import { EditorProvider } from '../../editor/EditorProvider';
import { ShortcutHelp } from '../../editor/ShortcutHelp';
import { WriterSidebar } from '../../components/WriterSidebar';
import { ProjectSidebar } from '../../components/ProjectSidebar';
import { WriterStatsPanel } from '../../editor/WriterStatsPanel';
import { ProjectHeader } from '../../components/ProjectHeader';
import { EditorTabBar } from '../../components/EditorTabBar';
import { NewChapterModal } from '../../components/NewChapterModal';
import { ConfirmDeleteDialog } from '../../components/ConfirmDeleteDialog';
import { ConfirmDialog } from '../../components/ConfirmDialog';
import { ShareDialog } from '../../components/ShareDialog';
import { WriteView } from '../../views/write';
import { StructureView } from '../../views/StructureView';
import { CharactersView } from '../../views/CharactersView';
import { NotesView } from '../../views/notes';
import { SynopsisView } from '../../views/synopsis';
import { GeminiSynopsisAgent } from '../../views/synopsis/AI/GeminiSynopsisAgent';
import { IdeaView } from '../../views/idea';
import { EmptyEditorState } from './components/EmptyEditorState';
import { RendererLogger as Logger } from '../../../../../shared/logger-renderer';
import { ProjectStructure } from '../../../../../shared/types';
import { useStructureStore } from '../../../../stores/useStructureStore';
import { EditorTab } from '../../../../../shared/editor';

// ğŸ”¥ Symbol ê¸°ë°˜ ì»´í¬ë„ŒíŠ¸ ì´ë¦„
const PROJECT_EDITOR = Symbol.for('PROJECT_EDITOR');

// ğŸ”¥ ëª¨ë“ˆí™”ëœ hooks ë° services
import { useProjectData } from '../../hooks/useProjectData';
import { useEditorState } from './hooks/useEditorState';
import { useEditorShortcuts } from './hooks/useEditorShortcuts';
import { EditorViewManager } from './views/EditorViewManager';
import { projectEditorStateService } from './services/ProjectEditorStateService';
import {
  createTabClickHandler,
  createTabCloseHandler,
  createNewTabHandler,
  createViewChangeHandler,
  createModalHandlers,
  createAISidebarToggleHandler,
} from './services/editorEventHandlers';
import ProjectEditorLayout from './components/ProjectEditorLayout';

export interface ProjectEditorProps {
    projectId: string;
}

type ProjectEditorView = 'write' | 'synopsis' | 'characters' | 'structure' | 'notes' | 'idea';
const PROJECT_EDITOR_VIEWS: readonly ProjectEditorView[] = ['write', 'synopsis', 'characters', 'structure', 'notes', 'idea'] as const;

// ğŸ”¥ React.memoë¡œ ë¬´í•œ ë¦¬ë Œë”ë§ ë°©ì§€
export const ProjectEditor = memo(function ProjectEditor({
    projectId
}: ProjectEditorProps): React.ReactElement {
    Logger.info(PROJECT_EDITOR, 'ProjectEditor render started', { projectId });

    // ğŸ”¥ Step 1 ë¦¬íŒ©í† ë§: í†µí•© ìƒíƒœ ê´€ë¦¬
    const { isLoading, error, ...projectData } = useProjectData(projectId);
    const { state, actions, ui } = useEditorState(projectId);
    
    // structure store actions
    const addStructureItem = useStructureStore((s) => s.addStructureItem);
    const updateStructureItem = useStructureStore((s) => s.updateStructureItem);
    const setCurrentEditor = useStructureStore((s) => s.setCurrentEditor);
    const loadStructuresFromDB = useStructureStore((s) => s.loadStructuresFromDB);

    // ğŸ”¥ Local UI state (hover ìƒíƒœëŠ” ì—¬ì „íˆ localë¡œ ìœ ì§€)
    const [tabBarHovered, setTabBarHovered] = useState(false);
    const [sidebarHovered, setSidebarHovered] = useState(false);
    const [editorInstance, setEditorInstance] = useState<Editor | null>(null);

    // ğŸ”¥ Create event handlers (memoized)
    const onTabClick = useCallback(
      () => createTabClickHandler({ projectId, state, actions }),
      [projectId, state, actions]
    )();
    const onTabClose = useCallback(
      () => createTabCloseHandler({ projectId, state, actions }),
      [projectId, state, actions]
    )();
    const onNewTab = useCallback(
      () => createNewTabHandler({ projectId, state, actions }),
      [projectId, state, actions]
    )();
    const onSidebarViewChange = useCallback(
      () => createViewChangeHandler({ projectId, state, actions }, 'expanded'),
      [projectId, state, actions]
    )();
    const onHoverSidebarViewChange = useCallback(
      () => createViewChangeHandler({ projectId, state, actions }, 'hover'),
      [projectId, state, actions]
    )();
    const { openNewChapterModal, openNewCharacterModal, openNewNoteModal } = useCallback(
      () => createModalHandlers({ projectId, state, actions }),
      [projectId, state, actions]
    )();
    const onToggleAISidebar = useCallback(
      () => createAISidebarToggleHandler({ projectId, state, actions }),
      [projectId, state, actions]
    )();

    // ğŸ”¥ Phase 0: í”„ë¡œì íŠ¸ ì§„ì… ì‹œ ìµœê·¼ ì¥ ìë™ ì˜¤í”ˆ
    useEffect(() => {
        if (projectId && state.tabs.length === 0) {
            // tabHistoryì—ì„œ ê°€ì¥ ìµœê·¼ì˜ chapter ì°¾ê¸°
            const recentChapterId = state.tabHistory.find(tabId => 
                tabId.startsWith('chapter-')
            );

            if (recentChapterId) {
                // ìµœê·¼ ì¥ì´ ìˆìœ¼ë©´ ìë™ìœ¼ë¡œ íƒ­ ì¶”ê°€
                const structureId = recentChapterId.replace('chapter-', '');
                const structures = useStructureStore.getState().structures[projectId] || [];
                const chapter = structures.find(s => s.id === structureId);

                if (chapter) {
                    actions.addTab({
                        id: recentChapterId,
                        title: chapter.title,
                        type: 'chapter',
                        chapterId: chapter.id,  // ğŸ”¥ CRITICAL: chapterId ë°˜ë“œì‹œ ì €ì¥
                        isActive: true,
                        content: chapter.content || ''
                    });
                    actions.setCurrentView('write');
                    Logger.info(PROJECT_EDITOR, 'Auto-opened recent chapter', { 
                        chapterId: chapter.id, 
                        title: chapter.title 
                    });
                }
            }
        }
    }, [projectId, state.tabs.length, state.tabHistory, actions]);

    // ğŸ”¥ NewChapterModal ìƒíƒœ ë””ë²„ê¹…
    useEffect(() => {
        Logger.debug(PROJECT_EDITOR, 'NewChapterModal state changed', { 
            showNewChapterModal: state.showNewChapterModal 
        });
    }, [state.showNewChapterModal]);

    // NOTE: error/loading rendering handled later after hooks are declared

    // ğŸ”¥ ì‚¬ì´ë“œë°” ê´€ë ¨ ìƒíƒœ (ì§‘ì¤‘ëª¨ë“œ ì œê±°, ì‚¬ì´ë“œë°” ì ‘ê¸°ë¡œ í†µí•©)
    const isZenMode = state.zenMode;
    const sidebarCollapsed = state.sidebarCollapsed;
    const isSidebarCollapsed = state.collapsed;

    // ğŸ”¥ ë””ë²„ê¹…: ì‚¬ì´ë“œë°” ìƒíƒœ í™•ì¸ 
    Logger.debug(PROJECT_EDITOR, 'Sidebar States', {
        isSidebarCollapsed: isSidebarCollapsed,
        mainCollapsed: state.collapsed,
        settingsCollapsed: sidebarCollapsed
    });

    // ğŸ”¥ ì €ì¥ ì„±ê³µ ì²˜ë¦¬
    const handleSaveSuccess = () => {
        actions.markAllTabsAsSaved();
        Logger.info(PROJECT_EDITOR, 'All tabs marked as saved');
    };

    // ğŸ”¥ actions ì•ˆì •ì  ì°¸ì¡°ë¥¼ ìœ„í•œ ref
    const actionsRef = useRef(actions);
    actionsRef.current = actions;

    // ğŸ”¥ ì €ì¥ ìƒíƒœ ê°ì‹œí•˜ì—¬ íƒ­ ìƒíƒœ ì—…ë°ì´íŠ¸ - ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
    const saveStatusRef = useRef<string>('');
    useEffect(() => {
        if (projectData.saveStatus === 'saved' && saveStatusRef.current !== 'saved') {
            saveStatusRef.current = 'saved';
            actionsRef.current.markAllTabsAsSaved();
            Logger.debug(PROJECT_EDITOR, 'Auto save completed - tabs updated');
        } else if (projectData.saveStatus !== 'saved') {
            saveStatusRef.current = projectData.saveStatus;
        }
    }, [projectData.saveStatus]);

    // ğŸ”¥ ì‚¬ì´ë“œë°” í† ê¸€ í•¨ìˆ˜
    const toggleSidebar = useCallback(() => {
        actions.toggleCollapsed();
        Logger.info('PROJECT_EDITOR', 'Sidebar toggled', { collapsed: !state.collapsed });
    }, [actions, state.collapsed]);

    // ğŸ”¥ ìˆ˜ë™ ì €ì¥ í•¨ìˆ˜ (Cmd+S / Ctrl+S)
    const handleManualSave = useCallback(async () => {
        if (projectData?.forceSave) {
            Logger.info('PROJECT_EDITOR', 'Manual save triggered');
            await projectData.forceSave();
        }
    }, [projectData]);

    // ğŸ”¥ Step 2 ë¦¬íŒ©í† ë§: í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ë¥¼ Hookìœ¼ë¡œ ë¶„ë¦¬
    useEditorShortcuts({
        projectId,
        isZenMode,
        onManualSave: handleManualSave,
        onToggleSidebar: toggleSidebar,
        onToggleZenMode: () => {
            if (isZenMode) {
                disableZenMode();
            } else {
                enableZenMode();
            }
        },
    });

    const enableZenMode = useCallback(() => {
        actions.toggleZenMode();
        Logger.info('PROJECT_EDITOR', 'Zen mode enabled');
    }, [actions]);

    const disableZenMode = useCallback(() => {
        actions.toggleZenMode();
        Logger.info('PROJECT_EDITOR', 'Zen mode disabled');
    }, [actions]);

    // ğŸ”¥ Phase 0: main íƒ­ ì œê±°ë¨ - ë” ì´ìƒ í•„ìš” ì—†ìŒ

    // ğŸ”¥ Settings sidebar collapsedì™€ local state ë™ê¸°í™”
    useEffect(() => {
        if (sidebarCollapsed !== state.collapsed) {
            if (sidebarCollapsed) {
                if (!state.collapsed) actions.toggleCollapsed();
            } else {
                if (state.collapsed) actions.toggleCollapsed();
            }
            Logger.debug('PROJECT_EDITOR', 'Sidebar state synced with settings', {
                settingsCollapsed: sidebarCollapsed,
                stateCollapsed: state.collapsed
            });
        }
    }, [sidebarCollapsed, state.collapsed, actions]);

    // ğŸ”¥ Chrome ìŠ¤íƒ€ì¼: ì´ˆê¸°ì—ëŠ” ë©”ì¸ íƒ­ë§Œ í‘œì‹œ
    // ì‚¬ìš©ìê°€ ì‚¬ì´ë“œë°”ì—ì„œ í´ë¦­í•  ë•Œë§ˆë‹¤ í•´ë‹¹ íƒ­ì´ ìƒì„±ë¨

    // ğŸ¯ Phase 14-D: Performance optimization with useMemo
    // âœ… ALL hooks MUST be declared BEFORE conditional returns (React Hooks Rules)
    
    // Memoize characters and notes arrays to prevent unnecessary re-renders
    const memoizedCharacters = React.useMemo(
        () => projectData?.characters || [],
        [projectData?.characters]
    );
    
    const memoizedNotes = React.useMemo(
        () => projectData?.notes || [],
        [projectData?.notes]
    );

    // ğŸ”¥ ë¡œë”© ìƒíƒœ ì²˜ë¦¬
    if (isLoading) {
        return (
            <ProjectEditorLayout.Container>
                <div className="flex items-center justify-center h-full">
                    <div className="flex flex-col items-center gap-4">
                        <div className="w-8 h-8 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                        <span className="text-slate-500 text-sm">í”„ë¡œì íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</span>
                    </div>
                </div>
            </ProjectEditorLayout.Container>
        );
    }

    // ğŸ”¥ ì—ëŸ¬ ìƒíƒœ ì²˜ë¦¬
    if (error) {
        return (
            <ProjectEditorLayout.Container>
                <div className="flex items-center justify-center h-full">
                    <div className="text-center">
                        <h1 className="text-2xl font-bold text-red-600 mb-4">ì˜¤ë¥˜</h1>
                        <p className="text-slate-600">{error}</p>
                    </div>
                </div>
            </ProjectEditorLayout.Container>
        );
    }

    // ğŸ”¥ í˜„ì¬ í™œì„± íƒ­ ì°¾ê¸°
    const activeTab = state.tabs.find(tab => tab.id === state.activeTabId);

    Logger.debug('PROJECT_EDITOR', 'Rendering with state', {
        currentView: state.currentView,
        activeTabId: state.activeTabId,
        tabsCount: state.tabs.length
    });

    const normalizedCurrentView = PROJECT_EDITOR_VIEWS.includes(state.currentView as ProjectEditorView)
        ? (state.currentView as ProjectEditorView)
        : 'write';

    const isWriteView = normalizedCurrentView === 'write';

    return (
        <ProjectEditorLayout.Container className="relative overflow-x-hidden">
            {/* ğŸ”¥ í—¤ë” + íƒ­ë°”ë¥¼ í•˜ë‚˜ì˜ ìŠ¤í‹°í‚¤ ì˜ì—­ìœ¼ë¡œ êµ¬ì„±í•˜ì—¬ ì•ˆì •ì ì¸ ë ˆì´ì–´ë§ í™•ë³´ */}
            <div className="sticky top-0 z-[1200] flex flex-col bg-[color:hsl(var(--card))] transition-colors duration-200 shadow-[var(--shadow-sm,0_10px_20px_rgba(15,23,42,0.08))]">
                {/* ğŸ”¥ ProjectHeader - ê¸€ì“°ê¸° íƒ­ì¼ ë•Œë§Œ í‘œì‹œ (Chrome ìŠ¤íƒ€ì¼) */}
                {state.currentView === 'write' && (
                    <ProjectEditorLayout.Header className="relative z-[1500] min-h-[3.5rem] shadow-none">
                        <ProjectHeader
                            title={projectData?.title || 'í”„ë¡œì íŠ¸'}
                            onTitleChange={(title) => {
                                projectData?.setTitle(title);
                                Logger.debug('PROJECT_EDITOR', 'Title changed', { title });
                            }}
                            onBack={() => {
                                Logger.debug('PROJECT_EDITOR', 'Back button clicked');
                                // /projectsë¡œ ì´ë™
                                if (typeof window !== 'undefined') {
                                    window.location.href = '/projects';
                                }
                            }}
                            editor={editorInstance}
                            sidebarCollapsed={isSidebarCollapsed}
                            onToggleSidebar={toggleSidebar}
                        />
                    </ProjectEditorLayout.Header>
                )}

                {/* ğŸ”¥ EditorTabBar - í—¤ë” ë°”ë¡œ ì•„ë˜ì— ë°°ì¹˜í•˜ì—¬ ìƒë‹¨ì—ì„œ í•­ìƒ ë…¸ì¶œ (Universal Tab System) */}
                <div className="relative overflow-hidden backdrop-blur-sm transition-all duration-200 border-b z-[1300] h-12 bg-[color:hsl(var(--muted))]/85 border-[color:hsl(var(--border))] opacity-100">
                    <EditorTabBar
                        tabs={state.tabs}
                        activeTabId={state.activeTabId}
                        currentView={normalizedCurrentView}
                        onTabClick={onTabClick}
                        onTabClose={onTabClose}
                        onNewTab={onNewTab}
                        onToggleAISidebar={onToggleAISidebar}
                        isAISidebarOpen={state.showRightSidebar}
                    />
                </div>
            </div>

            {/* ğŸ”¥ ë©”ì¸ ì»¨í…ì¸  ì˜ì—­ */}
            <ProjectEditorLayout.Main>
                {/* ğŸ”¥ ProjectSidebar hover ì˜ì—­ - ì™„ì „ íˆ¬ëª… */}
                {isSidebarCollapsed && (
                    <div
                        className="absolute left-0 top-0 w-8 h-full z-[100] opacity-0 cursor-pointer transition-all duration-200 hover:w-12"
                        onMouseEnter={() => {
                            setSidebarHovered(true);
                            Logger.debug('PROJECT_SIDEBAR', 'Hover activated');
                        }}
                        onMouseLeave={() => {
                            setSidebarHovered(false);
                            Logger.debug('PROJECT_SIDEBAR', 'Hover deactivated');
                        }}
                    >
                        {/* ì™„ì „ íˆ¬ëª… hover ì˜ì—­ */}
                    </div>
                )}

                {/* ğŸ”¥ ProjectSidebar í‘œì‹œ - í—¤ë” ì•„ë˜ ìœ„ì¹˜ ì¡°ì • */}
                {sidebarHovered && isSidebarCollapsed && (
                    <div
                        className="absolute left-0 top-0 w-64 h-full z-[150] bg-[color:hsl(var(--card))]/95 backdrop-blur-lg border-r border-[color:hsl(var(--border))] shadow-[var(--shadow-xl,0_22px_46px_rgba(15,23,42,0.32))] transition-all duration-500 ease-in-out transform translate-x-0 pointer-events-auto animate-slide-in-left"
                        onMouseEnter={() => {
                            Logger.debug('PROJECT_SIDEBAR', 'Hover area entered');
                            setSidebarHovered(true);
                        }}
                        onMouseLeave={() => {
                            Logger.debug('PROJECT_SIDEBAR', 'Hover area left');
                            setSidebarHovered(false);
                        }}
                    >
                        <div className="h-full overflow-y-auto p-4 pointer-events-auto">
                            <ProjectSidebar
                                projectId={projectId}
                                currentView={state.currentView}
                                onViewChange={onHoverSidebarViewChange}
                                structure={projectData?.structure || []}
                                characters={memoizedCharacters}
                                collapsed={false}
                                stats={{
                                    wordCount: projectData?.writerStats?.wordCount || 0,
                                    charCount: projectData?.writerStats?.charCount || 0,
                                    paragraphCount: projectData?.writerStats?.paragraphCount || 0,
                                    readingTime: projectData?.writerStats?.readingTime || 0,
                                    wordGoal: projectData?.writerStats?.wordGoal || 1000,
                                    progress: projectData?.writerStats?.progress || 0,
                                    sessionTime: projectData?.writerStats?.sessionTime || 0,
                                    wpm: projectData?.writerStats?.wpm || 0
                                }}
                                onAddStructure={openNewChapterModal}
                                onAddCharacter={openNewCharacterModal}
                                onAddNote={openNewNoteModal}
                            />
                        </div>
                    </div>
                )}

                {/* ğŸ”¥ ì¼ë°˜ ProjectSidebar (ì‚¬ì´ë“œë°” í¼ì³ì ¸ ìˆì„ ë•Œ) - absoluteë¡œ flowì—ì„œ ì œì™¸ */}
                {!isSidebarCollapsed && (
                    <div className="absolute left-0 top-0 w-80 h-full z-[140] bg-[color:hsl(var(--card))] border-r border-[color:hsl(var(--border))] overflow-hidden shadow-sm">
                        <ProjectSidebar
                            projectId={projectId}
                            currentView={state.currentView}
                            onViewChange={onSidebarViewChange}
                            structure={projectData?.structure || []}
                            characters={memoizedCharacters}
                            collapsed={false}
                            stats={{
                                wordCount: projectData?.writerStats?.wordCount || 0,
                                charCount: projectData?.writerStats?.charCount || 0,
                                paragraphCount: projectData?.writerStats?.paragraphCount || 0,
                                readingTime: projectData?.writerStats?.readingTime || 0,
                                wordGoal: projectData?.writerStats?.wordGoal || 1000,
                                progress: projectData?.writerStats?.progress || 0,
                                sessionTime: projectData?.writerStats?.sessionTime || 0,
                                wpm: projectData?.writerStats?.wpm || 0
                            }}
                            onAddStructure={openNewChapterModal}
                            onAddCharacter={openNewCharacterModal}
                            onAddNote={openNewNoteModal}
                        />
                    </div>
                )}

                {/* ğŸ”¥ ë©”ì¸ ì—ë””í„° + ìš°ì¸¡ë°”ë¥¼ flex rowë¡œ êµ¬ì„±í•˜ì—¬ ìŠ¤í¬ë¡¤ë°” ì œê±° */}
                <div className="flex flex-row flex-1 min-w-0 h-full overflow-hidden">
                    {/* ğŸ”¥ Empty State: ëª¨ë“  íƒ­ì´ ë‹«í˜€ìˆëŠ” ê²½ìš° */}
                    {state.tabs.length === 0 ? (
                        <div className="flex-1 min-w-0 overflow-hidden">
                            {(() => {
                                // ğŸ”¥ useProjectEditorStateì—ì„œ ì´ë¯¸ ìºì‹œ ë¡œë“œë¨
                                let cachedTabIds = Object.keys(state.tabMetadataCache);
                                                            
                                            // ğŸ”¥ 2ë‹¨ê³„: ìºì‹œê°€ ë¹„ì–´ìˆìœ¼ë©´ localStorageì—ì„œ ì§ì ‘ ë¡œë“œ
                                            if (cachedTabIds.length === 0) {
                                            const storageCached = projectEditorStateService.loadCacheFromStorage(projectId);
                                            cachedTabIds = Object.keys(storageCached);
                                            const firstKey = Object.keys(storageCached)[0];
                                            Logger.info('PROJECT_EDITOR_DETAIL', 'ğŸ” localStorage ë¡œë“œ ì‹œì‘', {
                                                            projectId,
                                                            storageCachedKeys: Object.keys(storageCached),
                                                            storageCachedSize: Object.keys(storageCached).length,
                                                            sample: firstKey ? storageCached[firstKey] : 'none'
                                                        });
                                                    Logger.debug(PROJECT_EDITOR, 'Loaded cache from localStorage', {
                                                                projectId,
                                                                loaded: cachedTabIds.length > 0,
                                                                cache: storageCached
                                                            });
                                    
                                    // ìºì‹œë¥¼ ìƒíƒœì— ì„¤ì •í•˜ë ¤ë©´ ë³„ë„ ì•¡ì…˜ì´ í•„ìš”
                                    // ì„ì‹œ: ì§ì ‘ ìºì‹œ ì‚¬ìš©
                                    if (cachedTabIds.length > 0) {
                                        const mostRecentTabId = cachedTabIds.reduce((latest, current) => {
                                            const latestMeta = storageCached[latest];
                                            const currentMeta = storageCached[current];
                                            if (!latestMeta || !currentMeta) return latest;
                                            return currentMeta.lastAccessedAt > latestMeta.lastAccessedAt ? current : latest;
                                        });
                                        
                                        const lastChapterMetadata = storageCached[mostRecentTabId];
                                        
                                        Logger.info('EMPTY_STATE_RENDER_STORAGE', 'Storage cache loaded', {
                                            mostRecentTabId,
                                            fullMetadata: JSON.stringify(lastChapterMetadata),
                                            keys: Object.keys(lastChapterMetadata || {}),
                                            chapterId_exists: !!lastChapterMetadata?.chapterId,
                                            chapterId_value: lastChapterMetadata?.chapterId,
                                            full_storageCached: JSON.stringify(storageCached)
                                        });
                                        
                                        return (
                                            <EmptyEditorState
                                                onCreateChapter={() => actions.openNewChapterModal()}
                                                onGoToLastChapter={() => {
                                                    Logger.info(PROJECT_EDITOR, 'Opening last chapter from storage', {
                                                        tabId: mostRecentTabId,
                                                        metadata: lastChapterMetadata,
                                                        chapterId_debug: lastChapterMetadata?.chapterId
                                                    });
                                                    
                                                    Logger.debug(PROJECT_EDITOR, 'Checking chapterId', {
                                                        hasChapterId: !!lastChapterMetadata?.chapterId,
                                                        chapterId: lastChapterMetadata?.chapterId,
                                                        metadata: lastChapterMetadata,
                                                        metadataKeys: Object.keys(lastChapterMetadata || {})
                                                    });
                                                    
                                                    if (lastChapterMetadata?.chapterId) {
                                                        // chapterIdë¡œ íƒ­ ì¬ìƒì„±
                                                        const structures = useStructureStore.getState().structures[projectId] || [];
                                                        Logger.debug(PROJECT_EDITOR, 'Loaded structures', {
                                                            projectId,
                                                            structureCount: structures.length,
                                                            searchingFor: lastChapterMetadata.chapterId
                                                        });
                                                        
                                                        const chapter = structures.find(s => s.id === lastChapterMetadata.chapterId);
                                                        Logger.debug(PROJECT_EDITOR, 'Chapter search result', {
                                                            found: !!chapter,
                                                            chapterId: chapter?.id,
                                                            title: chapter?.title
                                                        });
                                                        
                                                        if (chapter?.id) {
                                                            Logger.debug(PROJECT_EDITOR, 'Adding tab from structures', {
                                                                tabId: `chapter-${chapter.id}`,
                                                                title: chapter.title
                                                            });
                                                            actions.addTab({
                                                                id: `chapter-${chapter.id}`,
                                                                title: chapter.title || lastChapterMetadata.title,
                                                                type: 'chapter',
                                                                chapterId: chapter.id,
                                                                isActive: true
                                                            });
                                                            actions.setCurrentView('write');
                                                        } else {
                                                            // êµ¬ì¡° ë°ì´í„°ê°€ ì—†ìœ¼ë©´ íƒ­ë§Œ ì¶”ê°€
                                                            Logger.warn('PROJECT_EDITOR', 'Chapter not found in structures, using cached data');
                                                            Logger.debug('PROJECT_EDITOR', 'Adding tab from cache', {
                                                                tabId: mostRecentTabId,
                                                                title: lastChapterMetadata.title,
                                                                chapterId: lastChapterMetadata.chapterId
                                                            });
                                                            actions.addTab({
                                                                id: mostRecentTabId,
                                                                title: lastChapterMetadata.title,
                                                                type: 'chapter',
                                                                chapterId: lastChapterMetadata.chapterId,
                                                                isActive: true
                                                            });
                                                            actions.setCurrentView('write');
                                                        }
                                                    } else {
                                                        Logger.warn('PROJECT_EDITOR', 'No chapterId in metadata');
                                                    }
                                                }}
                                                hasLastChapter={!!lastChapterMetadata}
                                                lastChapterTitle={lastChapterMetadata?.title || ''}
                                            />
                                        );
                                    }
                                }
                                
                                // 3ë‹¨ê³„: state ìºì‹œ ì‚¬ìš©
                                const cachedMostRecentId = cachedTabIds.length > 0
                                    ? cachedTabIds.reduce((latest, current) => {
                                        const latestMeta = state.tabMetadataCache[latest];
                                        const currentMeta = state.tabMetadataCache[current];
                                        if (!latestMeta || !currentMeta) return latest;
                                        return currentMeta.lastAccessedAt > latestMeta.lastAccessedAt ? current : latest;
                                    })
                                    : null;
                                
                                const lastChapterMetadata = cachedMostRecentId ? state.tabMetadataCache[cachedMostRecentId] : null;
                                
                                return (
                                    <EmptyEditorState
                                        onCreateChapter={() => actions.openNewChapterModal()}
                                        onGoToLastChapter={() => {
                                            Logger.info(PROJECT_EDITOR, 'Opening last chapter from state cache', {
                                                tabId: cachedMostRecentId,
                                                metadata: lastChapterMetadata
                                            });
                                            
                                            if (cachedMostRecentId && lastChapterMetadata?.chapterId) {
                                                const structures = useStructureStore.getState().structures[projectId] || [];
                                                const chapter = structures.find(s => s.id === lastChapterMetadata.chapterId);
                                                
                                                if (chapter?.id) {
                                                    actions.addTab({
                                                        id: `chapter-${chapter.id}`,
                                                        title: chapter.title || lastChapterMetadata.title,
                                                        type: 'chapter',
                                                        chapterId: chapter.id,
                                                        isActive: true
                                                    });
                                                    actions.setCurrentView('write');
                                                }
                                            }
                                        }}
                                        hasLastChapter={!!lastChapterMetadata}
                                        lastChapterTitle={lastChapterMetadata?.title || ''}
                                    />
                                );
                            })()}
                        </div>
                    ) : (
                        <>
                            {/* ê° ë·°ì˜ ë©”ì¸ ì»¨í…ì¸  */}
                            <div className="flex-1 min-w-0 overflow-hidden">
                                <EditorViewManager
                                    currentView={state.currentView}
                                    activeTab={activeTab}
                                    projectId={projectId}
                                    projectData={projectData}
                                    memoizedCharacters={memoizedCharacters}
                                    memoizedNotes={memoizedNotes}
                                    editorInstance={editorInstance}
                                    onEditorReady={(editor) => {
                                        setEditorInstance(editor);
                                        Logger.debug(PROJECT_EDITOR, 'Editor instance received', { hasEditor: !!editor });
                                    }}
                                    onTabUpdate={(tabId, updates) => actions.updateTab(tabId, updates)}
                                    onViewChange={(view) => actions.setCurrentView(view)}
                                    onTabAdd={(tab) => actions.addTab(tab)}
                                    onOpenNewChapterModal={() => actions.openNewChapterModal()}
                                    setCurrentEditor={setCurrentEditor}
                                    updateStructureItem={updateStructureItem}
                                />
                            </div>

                            {/* ì˜¤ë¥¸ìª½ ì‚¬ì´ë“œë°” (AI íŒ¨ë„) - fixed width, shrink ì•ˆ í•¨ */}
                            {state.showRightSidebar && (
                                <div className="w-80 flex-shrink-0 overflow-hidden h-full border-l border-[color:hsl(var(--border))]">
                                    {normalizedCurrentView === 'synopsis' ? (
                                        <GeminiSynopsisAgent
                                            projectId={projectId}
                                            onClose={actions.toggleRightSidebar}
                                        />
                                    ) : (
                                        <WriterStatsPanel
                                            showRightSidebar={state.showRightSidebar}
                                            toggleRightSidebar={actions.toggleRightSidebar}
                                            writerStats={projectData?.writerStats || {
                                                wordCount: 0,
                                                charCount: 0,
                                                paragraphCount: 0,
                                                readingTime: 0,
                                                wordGoal: 1000,
                                                progress: 0,
                                                sessionTime: 0,
                                                wpm: 0,
                                                headingCount: 0,
                                                listItemCount: 0
                                            }}
                                            setWordGoal={(goal) => {
                                                projectData?.setWordGoal(goal);
                                            }}
                                            currentText={activeTab?.content || ''}
                                            projectId={projectId}
                                        />
                                    )}
                                </div>
                            )}
                        </>
                    )}
                </div>
            </ProjectEditorLayout.Main>

            {/* ëª¨ë‹¬ë“¤ */}
            {state.showDeleteDialog && (
                <ConfirmDeleteDialog
                    isOpen={state.showDeleteDialog}
                    projectTitle={projectData?.title || 'í”„ë¡œì íŠ¸'}
                    onConfirm={() => {
                        // TODO: í”„ë¡œì íŠ¸ ì‚­ì œ ë¡œì§
                        actions.closeDeleteDialog();
                    }}
                    onCancel={actions.closeDeleteDialog}
                />
            )}

            {state.showShareDialog && (
                <ShareDialog
                    isOpen={state.showShareDialog}
                    onClose={actions.closeShareDialog}
                    projectId={projectId}
                    projectTitle={projectData?.title || 'í”„ë¡œì íŠ¸'}
                />
            )}

            {state.showNewChapterModal && (
                <>
                    <NewChapterModal
                        isOpen={state.showNewChapterModal}
                        onClose={actions.closeNewChapterModal}
                        onConfirm={async (title: string) => {
                            // ìƒˆ ì±•í„° ìƒì„± ë¡œì§
                            const safeTitle = (title && title.trim()) || `ìƒˆ ì±•í„° ${Date.now()}`;

                            const newItem: ProjectStructure = {
                                id: `chapter_${Date.now()}`,
                                title: safeTitle,
                                description: '',
                                type: 'chapter',
                                status: 'draft',
                                wordCount: 0,
                                sortOrder: 0,
                                depth: 0,
                                color: '#6b7280',
                                isActive: true,
                                projectId,
                                createdAt: new Date(),
                                updatedAt: new Date(),
                            };

                            try {
                                await addStructureItem(projectId, newItem);

                                // ì—ë””í„° ìƒíƒœë¡œ ì „í™˜
                                setCurrentEditor({ projectId, editorType: 'chapter', itemId: newItem.id, itemTitle: newItem.title });

                                // ìƒˆ íƒ­ìœ¼ë¡œ ì±•í„° ì—´ê¸°
                                const newTab = {
                                    id: `chapter-${newItem.id}`,
                                    title: newItem.title,
                                    type: 'chapter' as const,
                                    isActive: true,
                                    chapterId: newItem.id,  // ğŸ”¥ CRITICAL: chapterId ë°˜ë“œì‹œ ì €ì¥
                                    content: ''
                                };
                                actions.addTab(newTab);
                                actions.setActiveTab(newTab.id);

                                Logger.info('PROJECT_EDITOR', 'New chapter created', { id: newItem.id, title: newItem.title });
                            } catch (error) {
                                Logger.error('PROJECT_EDITOR', 'Failed to create new chapter', { error });
                            } finally {
                                actions.closeNewChapterModal();
                            }
                        }}
                    />
                </>
            )}

            {/* TODO: NewCharacterModalê³¼ NewNoteModal ì»´í¬ë„ŒíŠ¸ ìƒì„± í•„ìš” */}
            {/* ì„ì‹œë¡œ NewChapterModalì„ ì¬ì‚¬ìš©í•˜ì—¬ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸ */}
            {state.showNewCharacterModal && (
                <NewChapterModal
                    isOpen={state.showNewCharacterModal}
                    onClose={actions.closeNewCharacterModal}
                    onConfirm={(title: string) => {
                        // TODO: ìƒˆ ìºë¦­í„° ìƒì„± ë¡œì§
                        actions.closeNewCharacterModal();
                    }}
                />
            )}

            {state.showNewNoteModal && (
                <NewChapterModal
                    isOpen={state.showNewNoteModal}
                    onClose={actions.closeNewNoteModal}
                    onConfirm={(title: string) => {
                        // TODO: ìƒˆ ë…¸íŠ¸ ìƒì„± ë¡œì§
                        actions.closeNewNoteModal();
                    }}
                />
            )}

            {/* ğŸ”¥ ë‹¨ì¶•í‚¤ ë„ì›€ë§ - ê¸€ì“°ê¸° ì—ë””í„°ì—ì„œë§Œ í‘œì‹œ */}
            <ShortcutHelp isEditorView={state.currentView === 'write'} />
        </ProjectEditorLayout.Container>
    );
});

export default ProjectEditor;
